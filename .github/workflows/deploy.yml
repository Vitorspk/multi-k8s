name: Deploy to GKE

on:
  push:
    branches:
      - master
      - main

env:
  PROJECT_ID: ${{ secrets.GCP_PROJECT_ID }}
  GKE_CLUSTER: ${{ secrets.GKE_CLUSTER_NAME || 'multi-k8s-cluster' }}
  GKE_ZONE: ${{ secrets.GKE_ZONE || 'southamerica-east1-a' }}
  DEPLOYMENT_NAME: ${{ secrets.DEPLOYMENT_NAME || 'multi-k8s' }}
  USE_GKE_GCLOUD_AUTH_PLUGIN: 'True'

jobs:
  setup-build-publish-deploy:
    name: Setup, Build, Publish, and Deploy
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout
      uses: actions/checkout@v3

    - name: Set up Cloud SDK
      uses: google-github-actions/setup-gcloud@v1
      with:
        version: 'latest'

    - name: Authenticate to Google Cloud
      uses: google-github-actions/auth@v1
      with:
        credentials_json: ${{ secrets.GCP_SA_KEY }}

    - name: Install GKE auth plugin
      run: |
        gcloud components install gke-gcloud-auth-plugin --quiet

    - name: Configure Docker to use gcloud as credential helper
      run: |
        gcloud auth configure-docker

    - name: Check if GKE cluster exists
      id: check-cluster
      run: |
        if gcloud container clusters describe $GKE_CLUSTER --zone=$GKE_ZONE --project=$PROJECT_ID &>/dev/null; then
          echo "cluster_exists=true" >> $GITHUB_OUTPUT
          echo "âœ… Cluster $GKE_CLUSTER exists in zone $GKE_ZONE"
        else
          echo "cluster_exists=false" >> $GITHUB_OUTPUT
          echo "âŒ Cluster $GKE_CLUSTER does not exist in zone $GKE_ZONE"
          echo "âš ï¸  Please run Terraform first to create the infrastructure:"
          echo "   cd terraform && terraform init && terraform apply"
        fi

    - name: Get GKE credentials
      if: steps.check-cluster.outputs.cluster_exists == 'true'
      run: |
        gcloud container clusters get-credentials $GKE_CLUSTER --zone $GKE_ZONE --project $PROJECT_ID

    - name: Get SHA
      id: sha
      run: echo "sha=$(git rev-parse HEAD)" >> $GITHUB_OUTPUT

    - name: Build Docker images
      if: steps.check-cluster.outputs.cluster_exists == 'true'
      run: |
        docker build -t gcr.io/${{ env.PROJECT_ID }}/multi-client:latest -t gcr.io/${{ env.PROJECT_ID }}/multi-client:${{ steps.sha.outputs.sha }} -f ./client/Dockerfile ./client
        docker build -t gcr.io/${{ env.PROJECT_ID }}/multi-server:latest -t gcr.io/${{ env.PROJECT_ID }}/multi-server:${{ steps.sha.outputs.sha }} -f ./server/Dockerfile ./server
        docker build -t gcr.io/${{ env.PROJECT_ID }}/multi-worker:latest -t gcr.io/${{ env.PROJECT_ID }}/multi-worker:${{ steps.sha.outputs.sha }} -f ./worker/Dockerfile ./worker

    - name: Push Docker images
      if: steps.check-cluster.outputs.cluster_exists == 'true'
      run: |
        docker push gcr.io/${{ env.PROJECT_ID }}/multi-client:latest
        docker push gcr.io/${{ env.PROJECT_ID }}/multi-client:${{ steps.sha.outputs.sha }}
        docker push gcr.io/${{ env.PROJECT_ID }}/multi-server:latest
        docker push gcr.io/${{ env.PROJECT_ID }}/multi-server:${{ steps.sha.outputs.sha }}
        docker push gcr.io/${{ env.PROJECT_ID }}/multi-worker:latest
        docker push gcr.io/${{ env.PROJECT_ID }}/multi-worker:${{ steps.sha.outputs.sha }}

    - name: Enable Secret Manager API
      if: steps.check-cluster.outputs.cluster_exists == 'true'
      run: |
        # Check if API is already enabled
        if gcloud services list --enabled --filter="config.name:secretmanager.googleapis.com" --format="value(config.name)" --project=$PROJECT_ID | grep -q secretmanager; then
          echo "âœ… Secret Manager API is already enabled"
        else
          echo "ðŸš€ Enabling Secret Manager API..."
          gcloud services enable secretmanager.googleapis.com --project=$PROJECT_ID || {
            echo "âš ï¸ Failed to enable Secret Manager API. It may require additional permissions."
            echo "You can enable it manually via Console or with appropriate permissions."
          }
        fi

    - name: Sync Secrets from Secret Manager
      if: steps.check-cluster.outputs.cluster_exists == 'true'
      run: |
        # Check if Secret Manager is accessible
        if gcloud secrets list --project=$PROJECT_ID --limit=1 &>/dev/null; then
          echo "âœ… Secret Manager is accessible, syncing secrets..."

          # Install Python dependencies if needed
          python3 -m pip install --upgrade pip

          # Run secret synchronization
          python3 scripts/sync-secrets.py --project-id=$PROJECT_ID || {
            echo "âš ï¸ Secret sync failed, falling back to manual creation"
            # Fallback: Create secrets manually with default values
            kubectl create secret generic database-secrets \
              --from-literal=PGPASSWORD="${{ secrets.POSTGRES_PASSWORD }}" \
              --from-literal=PGUSER="postgres" \
              --from-literal=PGHOST="postgres-cluster-ip-service" \
              --from-literal=PGPORT="5432" \
              --from-literal=PGDATABASE="postgres" \
              --dry-run=client -o yaml | kubectl apply -f -

            kubectl create secret generic redis-secrets \
              --from-literal=REDIS_HOST="redis-cluster-ip-service" \
              --from-literal=REDIS_PORT="6379" \
              --dry-run=client -o yaml | kubectl apply -f -
          }
        else
          echo "âš ï¸ Secret Manager not accessible, creating secrets manually..."

          # Create secrets manually with environment values
          kubectl create secret generic database-secrets \
            --from-literal=PGPASSWORD="${{ secrets.POSTGRES_PASSWORD }}" \
            --from-literal=PGUSER="postgres" \
            --from-literal=PGHOST="postgres-cluster-ip-service" \
            --from-literal=PGPORT="5432" \
            --from-literal=PGDATABASE="postgres" \
            --dry-run=client -o yaml | kubectl apply -f -

          kubectl create secret generic redis-secrets \
            --from-literal=REDIS_HOST="redis-cluster-ip-service" \
            --from-literal=REDIS_PORT="6379" \
            --dry-run=client -o yaml | kubectl apply -f -
        fi

        # Create legacy pgpassword secret for backward compatibility
        kubectl get secret pgpassword &>/dev/null || \
        kubectl create secret generic pgpassword \
          --from-literal=PGPASSWORD="${{ secrets.POSTGRES_PASSWORD }}"

    - name: Deploy to GKE
      if: steps.check-cluster.outputs.cluster_exists == 'true'
      run: |
        kubectl apply -f k8s/
        kubectl set image deployments/client-deployment client=gcr.io/${{ env.PROJECT_ID }}/multi-client:${{ steps.sha.outputs.sha }}
        kubectl set image deployments/server-deployment server=gcr.io/${{ env.PROJECT_ID }}/multi-server:${{ steps.sha.outputs.sha }}
        kubectl set image deployments/worker-deployment worker=gcr.io/${{ env.PROJECT_ID }}/multi-worker:${{ steps.sha.outputs.sha }}
        kubectl rollout status deployment/client-deployment
        kubectl rollout status deployment/server-deployment
        kubectl rollout status deployment/worker-deployment